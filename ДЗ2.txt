Задача 1:

Посчитайте для каждой игры из таблицы games, какой процент лайков принёс каждый аккаунт, связанный с этой игрой, от общего количества лайков по этой игре. Считать для игр, вышедших в 2017 году. Учитывать только твиты, написанные в 2017 году. Аккаунты, связанные с игрой, но не писавшие твитов / не получившие лайков - тоже учитывать (их сумма лайков должна быть 0). Считать без использования оконных функций. Результат должен состоять из колонок id, name, developer, release_date, twitter_account_id, twitter_account_name, sum_likes, total_likes, percent_of_total



Задача 2:

Для каждого уникального жанра игр посчитать количество игр в магазине, у которых рейтинг от топовых критиков в среднем больше либо равен 85. Вывести топ-10 жанров. Результат должен состоять из столбцов genre, games_count

Подсказка: столбец с жанрами нужно построчно разбить на уникальные жанры



Задача 3:

Для каждой игры, вышедшей в ноябре 2018 года, посчитайте количество уникальных профилей в каждой социально сети (таблица social_networks). Каждой социальной сети задайте правильно название (например, linkFacebook -> Facebook.com). Нельзя использовать CASE WHEN и multiIf. Результат должен содержать колонки id, name, social_network, count_social_network_accounts



Задача 4:

По таблице open_critic для каждого уникального ревьювера (комбинация стобцов author + company) и каждого их ревью достройте следующие столбцы - длина ревью (количество символов), средняя длина 3-х предыдущих ревью этого автора, средняя длина 3-х предыдущих ревью по этой игре. Результат должен содержать следующие колокни: company, author, date, game_name, comment, current_comment_length, previous_3_comment_average_length_this_author, previous_3_comment_average_length_this_game



Задача 5: 

Найти топ-10 пользователей по таблице tweets, написавших наибольшее количество твитов в 2016 году. Вывести всех их твиты. Для каждого твита посчитайте «бегущую сумму» лайков, реплаев, ретвитов, цитат отдельными столбцами от самого раннего твита до самого позднего за 2016 год («бегущая сумма» - сумма всех значений от самого первого до нынешнего значения включительно). Результат должен выводить столбцы twitter_account_id, text, quantity_likes, running_sum_likes, quantity_quotes, running_sum_quotes, quantity_retweets, running_sum_retweets, quantity_replys, running_sum_replys


Для заданий со звездочкой премиса общая:

Мы, онлайн-стриминговый сервис (например, twitch.tv). У нас есть таблица all_events, состоящая из столбцов partition_date, timestamp, user_id (идентификатор пользователя), stream_id (идентификатор трансляции), event_name. В event_name приходят следующие значения (события):
1) stream_start - начало стрима, т.е когда стример начинает трансляцию

2) stream_end - конец стрима, т.е когда стример заканчивает трансляцию

3) view_start - начало просмотра, т.е когда зритель начинает просмотр стрима

4) view_end - конец просмотра, т.е когда зритель заканчивает просмотр

Основная особенность таблицы - данные о событиях не всегда приходят последовательно. Т.е в идеальном мире события идут последовательно:
Для ДЗ2

Но в нашей таблице возможна следующая ситуация (и для событий по стримам, и для событий по просмотрам)

Для ДЗ2 (2)



*Задача 6:

Написать скрипт, который будет ежедневно добавлять из таблицы all_events в таблицу streams свежие данные. Таблица streams содержит данные об уникальных прошедших стримах: т.е каждая строка - это уникальная трансляция одного уникального стримера. Таблица streams состоит из следующих колонок partition_date, stream_start_timestamp, stream_end_timestamp, stream_id, streamer_id



*Задача 7:

Написать скрипт, который будет ежедневно добавлять из таблицы all_events в таблицу views свежие данные. Таблица views содержит данные об уникальных просмотрах стримов: т.е каждая строка - это уникальный просмотр одного уникального зрителя. Таблица views состоит из следующих колонок: partition_date, view_start_timestamp, view_end_timestamp, stream_id, viewer_id